 <!DOCTYPE html>
<html lang="en">
<head>
   <meta charset="UTF-8">
   <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
   <title>Sky Glide</title>
   <script src="https://unpkg.com/lucide@0.473.0/dist/umd/lucide.min.js" integrity="sha384-wB13QW3u6twSB0L9C2vdVl+93uSZEWRFrRlHqIjG9jcctrZO+9z145aCi5B8eFWo" crossorigin="anonymous"></script>
   <style>
       @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@400;600;800&display=swap');


       :root {
           --primary-color: #4EC0CA;
           --accent-color: #F4D03F;
           --text-color: #ffffff;
           --glass-bg: rgba(255, 255, 255, 0.15);
           --glass-border: rgba(255, 255, 255, 0.2);
           --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.37);
       }


       body {
           margin: 0;
           padding: 0;
           background: #2c3e50;
           background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
           overflow: hidden;
           font-family: 'Poppins', sans-serif;
           display: flex;
           justify-content: center;
           align-items: center;
           height: 100vh;
           user-select: none;
           -webkit-user-select: none;
           touch-action: none; /* Prevents mobile scrolling completely */
       }


       #game-container {
           position: relative;
           width: 100%;
           max-width: 480px;
           height: 100%;
           max-height: 800px;
           box-shadow: 0 0 50px rgba(0,0,0,0.5);
           overflow: hidden;
           border-radius: 4px;
           background-color: #4facfe; /* Fallback color */
       }


       canvas {
           display: block;
           width: 100%;
           height: 100%;
       }


       /* UI Overlay Layers */
       .ui-layer {
           position: absolute;
           top: 0;
           left: 0;
           width: 100%;
           height: 100%;
           pointer-events: none;
           display: flex;
           flex-direction: column;
           justify-content: center;
           align-items: center;
           transition: opacity 0.3s ease;
           z-index: 20;
       }


       .glass-panel {
           background: var(--glass-bg);
           backdrop-filter: blur(12px);
           -webkit-backdrop-filter: blur(12px);
           border: 1px solid var(--glass-border);
           border-radius: 20px;
           padding: 2rem;
           text-align: center;
           box-shadow: var(--shadow);
           pointer-events: auto;
           transform: translateY(20px);
           opacity: 0;
           animation: slideUp 0.5s forwards;
           min-width: 200px;
           max-width: 90%;
       }


       @keyframes slideUp {
           to { transform: translateY(0); opacity: 1; }
       }


       h1 {
           color: var(--text-color);
           font-size: 2.5rem;
           margin: 0 0 10px 0;
           text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
           font-weight: 800;
       }


       p {
           color: #eee;
           margin-bottom: 20px;
           font-size: 1rem;
       }


       .score-display {
           font-size: 4rem;
           font-weight: 800;
           color: var(--text-color);
           text-shadow: 2px 2px 10px rgba(0,0,0,0.5);
           margin: 0;
       }


       .score-label {
           font-size: 0.9rem;
           text-transform: uppercase;
           letter-spacing: 2px;
           opacity: 0.8;
           color: var(--text-color);
       }


       button {
           background: var(--accent-color);
           border: none;
           padding: 15px 40px;
           border-radius: 50px;
           font-size: 1.2rem;
           font-weight: 700;
           color: #2c3e50;
           cursor: pointer;
           transition: transform 0.1s, box-shadow 0.1s;
           box-shadow: 0 4px 15px rgba(244, 208, 63, 0.4);
           font-family: 'Poppins', sans-serif;
           -webkit-tap-highlight-color: transparent;
       }


       button:hover {
           transform: scale(1.05);
           background: #f7dc6f;
       }


       button:active {
           transform: scale(0.95);
       }

       .settings-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 100;
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            width: 44px;
            height: 44px;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            font-size: 24px;
            transition: transform 0.2s;
       }
       .settings-btn:hover { transform: rotate(45deg); }

       .control-row {
           display: flex;
           justify-content: space-between;
           align-items: center;
           margin-bottom: 12px;
           text-align: left;
           color: white;
       }
       .control-row label { font-weight: 500; font-size: 0.9rem; }
       input[type="color"] {
           -webkit-appearance: none;
           border: none;
           width: 32px;
           height: 32px;
           background: none;
           cursor: pointer;
           padding: 0;
       }
       input[type="color"]::-webkit-color-swatch-wrapper { padding: 0; border-radius: 50%; }
       input[type="color"]::-webkit-color-swatch { border: 2px solid white; border-radius: 50%; }

       .switch { position: relative; width: 42px; height: 24px; }
       .switch input { opacity: 0; width: 0; height: 0; }
       .slider { position: absolute; inset: 0; background-color: rgba(0,0,0,0.3); transition: .4s; border-radius: 34px; }
       .slider:before { position: absolute; content: ""; height: 16px; width: 16px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
       input:checked + .slider { background-color: var(--primary-color); }
       input:checked + .slider:before { transform: translateX(18px); }

       #hud {
           position: absolute;
           top: 20px;
           left: 0;
           width: 100%;
           text-align: center;
           pointer-events: none;
           z-index: 10;
       }


       #current-score {
           font-size: 3rem;
           font-weight: 800;
           color: white;
           text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
           display: none;
       }


       .hidden {
           display: none !important;
       }
   </style>
</head>
<body>


<div id="game-container">
   <canvas id="gameCanvas"></canvas>

    <div class="settings-btn" id="settings-btn"><i data-lucide="settings"></i></div>

   <!-- HUD -->
   <div id="hud">
       <span id="current-score">0</span>
   </div>


   <!-- Start Screen -->
   <div id="start-screen" class="ui-layer">
       <div class="glass-panel">
           <h1>SKY GLIDE</h1>
           <p>Tap, Click, or Spacebar to Fly</p>
           <p style="font-size: 0.8rem; opacity: 0.7">Best Score: <span id="start-best">0</span></p>
           <button id="start-btn">PLAY NOW</button>
       </div>
   </div>


   <!-- Game Over Screen -->
   <div id="game-over-screen" class="ui-layer hidden">
       <div class="glass-panel">
           <h1>GAME OVER</h1>
           <div class="score-label">SCORE</div>
           <div class="score-display" id="final-score">0</div>
           <div class="score-label" style="margin-top: 15px;">BEST</div>
           <div class="score-display" id="best-score" style="font-size: 2rem;">0</div>
           <br>
           <button id="restart-btn">TRY AGAIN</button>
       </div>
   </div>

   <!-- Settings Screen -->
    <div id="settings-screen" class="ui-layer hidden">
        <div class="glass-panel">
            <h1>Settings</h1>
            <div class="control-row">
                <label for="auto-fly">Auto Fly</label>
                <label class="switch"><input type="checkbox" id="auto-fly"><span class="slider"></span></label>
            </div>
             <div class="control-row">
                <label for="rainbow-bird">Rainbow Bird</label>
                <label class="switch"><input type="checkbox" id="rainbow-bird"><span class="slider"></span></label>
            </div>
            <div class="control-row">
                <label for="bird-color">Bird Color</label>
                <input type="color" id="bird-color" value="#F4D03F">
            </div>
            <div class="control-row">
                <label for="rainbow-pipes">Rainbow Pipes</label>
                <label class="switch"><input type="checkbox" id="rainbow-pipes"><span class="slider"></span></label>
            </div>
            <div class="control-row">
                <label for="pipe-color">Pipe Color</label>
                <input type="color" id="pipe-color" value="#73C6B6">
            </div>
            <div class="control-row">
                <label for="gold-pipe-rarity">Golden Pipe Rarity (1/x)</label>
                <input type="range" id="gold-pipe-rarity" min="1" max="50" value="10">
            </div>
            <div class="control-row">
                <label for="gravity">Gravity</label>
                <input type="range" id="gravity" min="0.1" max="1.0" step="0.05" value="0.25">
            </div>
            <div class="control-row">
                <label for="game-speed">Game Speed</label>
                <input type="range" id="game-speed" min="1.0" max="10.0" step="0.5" value="2.5">
            </div>
            <br>
            <button id="close-settings-btn">Close</button>
        </div>
    </div>
</div>


<script>
   // --- Configuration ---
   const canvas = document.getElementById('gameCanvas');
   const ctx = canvas.getContext('2d', { alpha: false }); // Optimizes performance
  
   const config = {
       gravity: 0.25,
       jumpStrength: -5.5,
       speed: 2.5,
       pipeSpawnRate: 180,
       pipeGap: 170,
       birdRadius: 16,
       autoFly: false,
       birdColor: '#F4D03F',
       pipeColor: '#73C6B6',
       rainbowBird: false,
       rainbowPipes: false,
       goldPipeRarity: 10
   };


   // --- High Score Safety ---
   let highScore = 0;
   try {
       highScore = localStorage.getItem('skyGlideHighScore') || 0;
   } catch (e) {
       console.warn('LocalStorage not available');
   }


   // State
   let frames = 0;
   let score = 0;
   let gameState = 'START';
   let particles = [];
  
   // DOM Elements
   const startScreen = document.getElementById('start-screen');
   const gameOverScreen = document.getElementById('game-over-screen');
   const hudScore = document.getElementById('current-score');
   const finalScoreEl = document.getElementById('final-score');
   const bestScoreEl = document.getElementById('best-score');
   const startBestEl = document.getElementById('start-best');
   const startBtn = document.getElementById('start-btn');
   const restartBtn = document.getElementById('restart-btn');
   const settingsBtn = document.getElementById('settings-btn');
   const settingsScreen = document.getElementById('settings-screen');
   const closeSettingsBtn = document.getElementById('close-settings-btn');

   // Settings elements
   const autoFlyCheck = document.getElementById('auto-fly');
   const birdColorInput = document.getElementById('bird-color');
   const pipeColorInput = document.getElementById('pipe-color');
   const rainbowBirdCheck = document.getElementById('rainbow-bird');
   const rainbowPipesCheck = document.getElementById('rainbow-pipes');
   const goldPipeRaritySlider = document.getElementById('gold-pipe-rarity');
   const gravitySlider = document.getElementById('gravity');
   const speedSlider = document.getElementById('game-speed');

   startBestEl.innerText = highScore;


   // Resize handling - Debounced to prevent flicker/crashes
   function resize() {
       const container = document.getElementById('game-container');
       // Ensure non-zero dimensions
       canvas.width = Math.max(container.clientWidth, 320);
       canvas.height = Math.max(container.clientHeight, 480);
   }
   window.addEventListener('resize', resize);
   resize();


   // --- Definitions (Moved Classes Up for Safety) ---


   class Particle {
       constructor(x, y) {
           this.x = x;
           this.y = y;
           this.size = Math.random() * 5 + 2;
           this.speedX = Math.random() * 2 - 1;
           this.speedY = Math.random() * 2 + 1;
           this.color = `rgba(255, 255, 255, ${Math.random() * 0.5 + 0.1})`;
           this.life = 1.0;
       }
       update() {
           this.x -= this.speedX + config.speed;
           this.y += this.speedY;
           this.life -= 0.03;
       }
       draw() {
           ctx.fillStyle = this.color;
           ctx.beginPath();
           ctx.arc(this.x, this.y, Math.max(0, this.size * this.life), 0, Math.PI * 2);
           ctx.fill();
       }
   }


   // --- Game Assets & Objects ---


   const clouds = [];
   // Initialize clouds once
   for(let i=0; i<5; i++) {
       clouds.push({
           x: Math.random() * canvas.width,
           y: Math.random() * canvas.height * 0.6,
           w: 60 + Math.random() * 40,
           s: 0.2 + Math.random() * 0.3
       });
   }


   const bird = {
       x: canvas.width / 4, // Default pos
       y: canvas.height / 2,
       velocity: 0,
       rotation: 0,
      
       draw: function() {
           ctx.save();
           ctx.translate(this.x, this.y);
          
           // Limit rotation angles
           let targetRotation = 0;
           if (this.velocity < 0) targetRotation = -25 * Math.PI / 180;
           else if (this.velocity > 0) targetRotation = 70 * Math.PI / 180;
          
           this.rotation += (targetRotation - this.rotation) * 0.1;
           ctx.rotate(this.rotation);


           // Bird Body
           let birdFill;
           if (config.rainbowBird) {
               birdFill = `hsl(${frames * 2 % 360}, 100%, 50%)`;
           } else {
                let gradient = ctx.createRadialGradient(-5, -5, 2, 0, 0, 20);
                gradient.addColorStop(0, config.birdColor);
                gradient.addColorStop(1, '#F39C12');
                birdFill = gradient;
           }
          
           ctx.beginPath();
           ctx.arc(0, 0, config.birdRadius, 0, Math.PI * 2);
           ctx.fillStyle = birdFill;
           ctx.fill();
           ctx.lineWidth = 2;
           ctx.strokeStyle = '#fff';
           ctx.stroke();


           // Eye
           ctx.beginPath();
           ctx.arc(6, -6, 5, 0, Math.PI*2);
           ctx.fillStyle = 'white';
           ctx.fill();
           ctx.beginPath();
           ctx.arc(8, -6, 2, 0, Math.PI*2);
           ctx.fillStyle = 'black';
           ctx.fill();


           // Beak
           ctx.beginPath();
           ctx.moveTo(8, 2);
           ctx.lineTo(16, 6);
           ctx.lineTo(8, 10);
           ctx.fillStyle = '#E74C3C';
           ctx.fill();


           // Wing
           ctx.beginPath();
           ctx.ellipse(-6, 2, 8, 5, -0.2, 0, Math.PI * 2);
           ctx.fillStyle = 'rgba(255,255,255,0.6)';
           ctx.fill();


           ctx.restore();
       },
      
       update: function() {
           if (gameState === 'GET_READY') {
               this.y = (canvas.height / 2) + Math.sin(frames * 0.1) * 10;
               this.x = canvas.width / 4; // Ensure x stays correct
               this.velocity = 0;
               this.rotation = 0;
           } else if (gameState === 'PLAYING') {
                if (config.autoFly) {
                    if (this.y > canvas.height / 2 + 50) {
                        this.flap();
                    }
                }
               this.velocity += config.gravity;
               this.y += this.velocity;


               // Ceiling collision (optional, but prevents flying over pipes)
               if (this.y < 0) {
                   this.y = 0;
                   this.velocity = 0;
               }


               // Floor collision
               if (this.y + config.birdRadius >= canvas.height) {
                   this.y = canvas.height - config.birdRadius;
                   gameOver();
               }
           }
       },
      
       flap: function() {
           this.velocity = config.jumpStrength;
           // Limit particles to prevent memory issues
           if (particles.length < 50) {
               for(let i=0; i<5; i++) {
                   particles.push(new Particle(this.x - 10, this.y + 10));
               }
           }
       }
   };


   const pipes = {
       items: [],
      
       reset: function() {
           this.items = [];
       },


       draw: function() {
           for(let i = 0; i < this.items.length; i++) {
               let p = this.items[i];
               if (!p) continue;

               let fillStyle;
                if (p.golden) {
                    let grad = ctx.createLinearGradient(p.x, 0, p.x + p.w, 0);
                    grad.addColorStop(0, '#FFD700');
                    grad.addColorStop(0.5, '#FFFF00');
                    grad.addColorStop(1, '#DAA520');
                    fillStyle = grad;
                } else if (config.rainbowPipes) {
                    fillStyle = `hsl(${frames * 2 % 360}, 100%, 50%)`;
                } else {
                    let grad = ctx.createLinearGradient(p.x, 0, p.x + p.w, 0);
                    grad.addColorStop(0, config.pipeColor);
                    grad.addColorStop(0.5, '#A3E4D7');
                    grad.addColorStop(1, config.pipeColor);
                    fillStyle = grad;
                }
               ctx.fillStyle = fillStyle;
              
               // Top Pipe
               if (p.top > 0) {
                   ctx.fillRect(p.x, 0, p.w, p.top);
                   ctx.fillRect(p.x - 2, p.top - 20, p.w + 4, 20);
                   ctx.strokeStyle = "rgba(255,255,255,0.3)";
                   ctx.lineWidth = 1;
                   ctx.strokeRect(p.x, 0, p.w, p.top);
               }
              
               // Bottom Pipe
               if (p.bottom > 0) {
                   ctx.fillRect(p.x, canvas.height - p.bottom, p.w, p.bottom);
                   ctx.fillRect(p.x - 2, canvas.height - p.bottom, p.w + 4, 20);
                   ctx.strokeStyle = "rgba(255,255,255,0.3)";
                   ctx.strokeRect(p.x, canvas.height - p.bottom, p.w, p.bottom);
               }
           }
       },
      
       update: function() {
           // Spawn logic
           if (frames % config.pipeSpawnRate === 0) {
               const minPipeHeight = 50;
               // Safeguard against negative math
               const availableSpace = Math.max(50, canvas.height - config.pipeGap - (minPipeHeight * 2));
               const topHeight = minPipeHeight + Math.random() * availableSpace;
               const bottomHeight = canvas.height - config.pipeGap - topHeight;
               const isGolden = Math.random() < 1 / config.goldPipeRarity;

               this.items.push({
                   x: canvas.width,
                   w: 60,
                   top: topHeight,
                   bottom: Math.max(0, bottomHeight), // Ensure non-negative
                   passed: false,
                   golden: isGolden
               });
           }


           for(let i = 0; i < this.items.length; i++) {
               let p = this.items[i];
               p.x -= config.speed;


               // Collision Detection
               // 1. Top Pipe
               if (
                   bird.x + config.birdRadius > p.x &&
                   bird.x - config.birdRadius < p.x + p.w &&
                   bird.y - config.birdRadius < p.top
               ) {
                   gameOver();
               }


               // 2. Bottom Pipe
               if (
                   bird.x + config.birdRadius > p.x &&
                   bird.x - config.birdRadius < p.x + p.w &&
                   bird.y + config.birdRadius > canvas.height - p.bottom
               ) {
                   gameOver();
               }


               // Scoring
               if (p.x + p.w < bird.x && !p.passed) {
                   score += p.golden ? 100 : 1;
                   hudScore.innerText = score;
                   p.passed = true;
               }


               // Cleanup - CRITICAL FIX: Use splice, not shift/index math
               if (p.x + p.w < -10) { // Buffer zone
                   this.items.splice(i, 1);
                   i--; // Adjust index so we don't skip the next item
               }
           }
       }
   };


   function handleParticles() {
       for (let i = 0; i < particles.length; i++) {
           particles[i].update();
           particles[i].draw();
           if (particles[i].life <= 0) {
               particles.splice(i, 1);
               i--;
           }
       }
   }


   function drawBackground() {
       let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
       grad.addColorStop(0, '#4facfe');
       grad.addColorStop(1, '#00f2fe');
       ctx.fillStyle = grad;
       ctx.fillRect(0, 0, canvas.width, canvas.height);


       ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
       clouds.forEach(cloud => {
           if(gameState === 'PLAYING') cloud.x -= cloud.s;
           if(cloud.x + cloud.w < 0) cloud.x = canvas.width;
          
           ctx.beginPath();
           ctx.arc(cloud.x, cloud.y, cloud.w/2, 0, Math.PI*2);
           ctx.arc(cloud.x + 20, cloud.y - 10, cloud.w/2, 0, Math.PI*2);
           ctx.arc(cloud.x + 40, cloud.y, cloud.w/2, 0, Math.PI*2);
           ctx.fill();
       });
   }


   function resetGame() {
       resize(); // Ensure size is correct on start
       bird.x = canvas.width / 4;
       bird.y = canvas.height / 2;
       bird.velocity = 0;
       bird.rotation = 0;
       pipes.reset();
       score = 0;
       frames = 0;
       particles = [];
       hudScore.innerText = score;
       hudScore.style.display = 'block';
   }


   function startGame() {
       if(gameState === 'PLAYING') return; // Prevent double clicks
       startScreen.classList.add('hidden');
       gameOverScreen.classList.add('hidden');
       resetGame();
       gameState = 'GET_READY';
      
       // Small delay to prevent accidental first jump
       setTimeout(() => {
           // Ready for input
       }, 100);
   }


   function activateGame(e) {
       if (e && e.type === 'touchstart') {
            // e.preventDefault(); // handled by CSS touch-action
       }
      
       if(gameState === 'GET_READY') {
           gameState = 'PLAYING';
           bird.flap();
       } else if (gameState === 'PLAYING') {
           bird.flap();
       }
   }


   function gameOver() {
       if (gameState === 'GAMEOVER') return; // Prevent multiple triggers
       gameState = 'GAMEOVER';
       hudScore.style.display = 'none';
      
       if (score > highScore) {
           highScore = score;
           try {
               localStorage.setItem('skyGlideHighScore', highScore);
           } catch (e) {}
       }


       finalScoreEl.innerText = score;
       bestScoreEl.innerText = highScore;
      
       gameOverScreen.classList.remove('hidden');
   }


   // --- Event Listeners ---
  
   window.addEventListener('keydown', (e) => {
       if (e.code === 'Space') {
           if (gameState === 'START' || gameState === 'GAMEOVER') return;
           activateGame();
       }
   });


   const container = document.getElementById('game-container');
  
   // Unified Input Handler
   const handleInput = (e) => {
       if (e.target.tagName === 'BUTTON') return;
       activateGame(e);
   };


   container.addEventListener('mousedown', handleInput);
   container.addEventListener('touchstart', handleInput, {passive: false});


   startBtn.addEventListener('click', startGame);
   restartBtn.addEventListener('click', startGame);

   settingsBtn.addEventListener('click', () => {
       settingsScreen.classList.remove('hidden');
       startScreen.classList.add('hidden');
       gameOverScreen.classList.add('hidden');
   });

   closeSettingsBtn.addEventListener('click', () => {
       settingsScreen.classList.add('hidden');
       if (gameState === 'START') {
           startScreen.classList.remove('hidden');
       } else if (gameState === 'GAMEOVER') {
           gameOverScreen.classList.remove('hidden');
       }
   });

    function saveSettings() {
        localStorage.setItem('skyGlideSettings', JSON.stringify(config));
    }

    function loadSettings() {
        try {
            const saved = JSON.parse(localStorage.getItem('skyGlideSettings'));
            if (saved) {
                Object.assign(config, saved);
            }
        } catch(e) { console.warn("Could not load settings"); }

        autoFlyCheck.checked = config.autoFly;
        birdColorInput.value = config.birdColor;
        pipeColorInput.value = config.pipeColor;
        rainbowBirdCheck.checked = config.rainbowBird;
        rainbowPipesCheck.checked = config.rainbowPipes;
        goldPipeRaritySlider.value = config.goldPipeRarity;
        gravitySlider.value = config.gravity;
        speedSlider.value = config.speed;
    }

    autoFlyCheck.addEventListener('change', () => { config.autoFly = autoFlyCheck.checked; saveSettings(); });
    birdColorInput.addEventListener('input', () => { config.birdColor = birdColorInput.value; saveSettings(); });
    pipeColorInput.addEventListener('input', () => { config.pipeColor = pipeColorInput.value; saveSettings(); });
    rainbowBirdCheck.addEventListener('change', () => { config.rainbowBird = rainbowBirdCheck.checked; saveSettings(); });
    rainbowPipesCheck.addEventListener('change', () => { config.rainbowPipes = rainbowPipesCheck.checked; saveSettings(); });
    goldPipeRaritySlider.addEventListener('input', () => { config.goldPipeRarity = goldPipeRaritySlider.value; saveSettings(); });
    gravitySlider.addEventListener('input', () => { config.gravity = parseFloat(gravitySlider.value); saveSettings(); });
    speedSlider.addEventListener('input', () => { config.speed = parseFloat(speedSlider.value); saveSettings(); });


   // --- Game Loop ---


   function loop() {
       // Clear
       ctx.clearRect(0, 0, canvas.width, canvas.height);


       // Draw World
       drawBackground();
       pipes.draw();
      
       // Update Logic
       if (gameState === 'PLAYING') {
           pipes.update();
           frames++;
       }
      
       bird.update();
       bird.draw();
       handleParticles();


       requestAnimationFrame(loop);
   }


   // Start Loop
   loadSettings();
   lucide.createIcons();
   loop();


</script>

<script>
    // Get the element by its ID
    const footerElement = document.getElementById('nexus-footer');

    // Wait for 20 seconds (20000 milliseconds)
    setTimeout(() => {
        // Change the font size (e.g., to 8px)
        footerElement.style.fontSize = '8px';
        
        // Make the background transparent
        footerElement.style.backgroundColor = 'rgba(0, 0, 0, 0)';
        
        // Optional: Gradually reduce opacity to fade it out slightly
        footerElement.style.opacity = '0.5'; 
    }, 20000); 
</script>

</div>
</body>
</html>
